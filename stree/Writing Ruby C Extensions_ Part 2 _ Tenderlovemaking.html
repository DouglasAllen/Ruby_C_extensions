<!DOCTYPE html>
<!-- saved from url=(0077)https://tenderlovemaking.com/2010/12/11/writing-ruby-c-extensions-part-2.html -->
<html class=" com-genius-Genius-js com-genius-Genius-no-touch"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">

    <title>
       Writing Ruby C Extensions: Part 2 |  Tenderlovemaking
    </title>

    <!-- atom feed -->
    <link href="https://tenderlovemaking.com/atom.xml" rel="alternate" title="Writing Ruby C Extensions: Part 2" type="application/atom+xml">

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/bootstrap.min.css">

    <!-- Optional theme -->
    <link rel="stylesheet" href="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/bootstrap-theme.min.css">

    <link rel="stylesheet" href="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/syntax.css">
    <link rel="stylesheet" href="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/main.css">

    <!-- Latest compiled and minified JavaScript -->
    <script id="twitter-wjs" src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/widgets.js.download"></script><script src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/jquery.min.js.download"></script>
    <script src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/bootstrap.min.js.download"></script>
    <script async="" src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/saved_resource"></script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-1260604-1']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
      })();
    </script><script type="text/javascript" async="" src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/ga.js.download"></script>
  <link rel="stylesheet" href="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/injection-3062c422a82df14992741eed284f0946.css" type="text/css"><script type="text/javascript" charset="utf-8" async="" src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/button.5546439b5d743401ca910708312f6e81.js.download"></script></head>

  <body class="home">

  <div class="container">
    <header class="masthead">
      <a href="https://tenderlovemaking.com/">
      <img src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/header-logo-text-trimmed.png" alt="Tenderlove Making">
      </a>
    </header>
    <article>
  <div class="post">
    <h1 class="posted-title"><a href="https://tenderlovemaking.com/2010/12/11/writing-ruby-c-extensions-part-2.html#">Writing Ruby C Extensions: Part 2</a></h1>
    <span class="post-date">
      2010-12-11 @ 16:25
    </span>
  
    <div class="entry">
      <p>OMG!  It's been a year since I posted<genius-referent data-genius-referent-id="9920610" data-genius-style-id="referent" data-genius-wrapped-path="/9920610/tenderlovemaking.com/2010/12/11/writing-ruby-c-extensions-part-2.html" data-genius-api-path="/referents/9920610" data-genius-annotator-id="3438427" data-genius-featured-referent="true" data-genius-hover=""> </genius-referent><a href="http://tenderlovemaking.com/2009/12/18/writing-ruby-c-extensions-part-1/"><genius-referent data-genius-referent-id="9920610" data-genius-style-id="referent" data-genius-wrapped-path="/9920610/tenderlovemaking.com/2010/12/11/writing-ruby-c-extensions-part-2.html" data-genius-api-path="/referents/9920610" data-genius-annotator-id="3438427" data-genius-featured-referent="true" data-genius-hover="">Writing Ruby C Extensions: Part 1</genius-referent></a>.  The first post I did was for the Ruby Advent Calendar in 2009.  I guess it's fitting that I write a blog post for the <a href="http://atnd.org/events/10439">Ruby Advent Calendar 2010</a>.  Anyway, if you haven't read part 1, <a href="http://tenderlovemaking.com/2009/12/18/writing-ruby-c-extensions-part-1/">please go read it now</a>.</p>

<p>In Part 2, we'll modify our <code>extconf.rb</code> file to find important files in <code>libstree</code>, then we'll create a Ruby class that is backed by a C structure.</p>

<p>The final code associated with this part of of my Writing Ruby C Extensions series can be found <a href="https://github.com/tenderlove/stree/tree/part2">here</a>.</p>

<h2>Using mkmf to find libraries</h2>

<p>As I mentioned in the <a href="http://tenderlovemaking.com/2009/12/18/writing-ruby-c-extensions-part-1/">previous post</a>, <code>extconf.rb</code> is used when installing a native gem to locate libraries, header files, and test various things about the target system before installing.  We're going to teach our extconf.rb file to locate the <code>libstree</code> dynamic library along with the header files.  We're also going to allow people to tell the gem where to find <code>libstree</code>, and set up our <code>extconf.rb</code> with some sensible defaults.</p>

<h3>mkmf configuration with <code>dir_config</code></h3>

<p>The first thing we'll do is tell <code>mkmf</code> where to look for <code>libstree</code> files by default.  We do this using the <code>dir_config</code> method.  <code>dir_config</code> takes three arguments:</p>

<ul>
<li>An arbitrary string, but usually the library name (like "stree")</li>
<li>A list of paths to search for header files</li>
<li>A list of paths to search for library files</li>
</ul>

<p>The <code>dir_config</code> method also allows users installing our gem to configure where mkmf should look for various files.  Let's take a look at our call to <code>dir_config</code> and talk about what it does:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="constant">LIBDIR</span>      = <span class="constant">Config</span>::<span class="constant">CONFIG</span>[<span class="string"><span class="delimiter">'</span><span class="content">libdir</span><span class="delimiter">'</span></span>]
<span class="constant">INCLUDEDIR</span>  = <span class="constant">Config</span>::<span class="constant">CONFIG</span>[<span class="string"><span class="delimiter">'</span><span class="content">includedir</span><span class="delimiter">'</span></span>]

<span class="constant">HEADER_DIRS</span> = [
  <span class="comment"># First search /opt/local for macports</span>
  <span class="string"><span class="delimiter">'</span><span class="content">/opt/local/include</span><span class="delimiter">'</span></span>,

  <span class="comment"># Then search /usr/local for people that installed from source</span>
  <span class="string"><span class="delimiter">'</span><span class="content">/usr/local/include</span><span class="delimiter">'</span></span>,

  <span class="comment"># Check the ruby install locations</span>
  <span class="constant">INCLUDEDIR</span>,

  <span class="comment"># Finally fall back to /usr</span>
  <span class="string"><span class="delimiter">'</span><span class="content">/usr/include</span><span class="delimiter">'</span></span>,
]

<span class="constant">LIB_DIRS</span> = [
  <span class="comment"># First search /opt/local for macports</span>
  <span class="string"><span class="delimiter">'</span><span class="content">/opt/local/lib</span><span class="delimiter">'</span></span>,

  <span class="comment"># Then search /usr/local for people that installed from source</span>
  <span class="string"><span class="delimiter">'</span><span class="content">/usr/local/lib</span><span class="delimiter">'</span></span>,

  <span class="comment"># Check the ruby install locations</span>
  <span class="constant">LIBDIR</span>,

  <span class="comment"># Finally fall back to /usr</span>
  <span class="string"><span class="delimiter">'</span><span class="content">/usr/lib</span><span class="delimiter">'</span></span>,
]

dir_config(<span class="string"><span class="delimiter">'</span><span class="content">stree</span><span class="delimiter">'</span></span>, <span class="constant">HEADER_DIRS</span>, <span class="constant">LIB_DIRS</span>)
</pre></div>
</div>
</div>

<p>First, this code builds a two lists of sensible defaults for finding header files and library files.  The <code>HEADER_FILES</code> and <code>LIB_DIRS</code> constants contain lists of common places to find libraries.  These settings will be nice for our users because if they have <code>libstree</code> installed in <code>/opt/local/</code> or <code>/usr/local/</code> it will find the library without any user intervention.</p>

<p>Finally, we call <code>dir_config</code> with the string "stree" and two lists.  This call to <code>dir_config</code> <em>only configures</em> mkmf with directories to search.  We actually haven't done any searching at this point.  The <code>dir_config</code> call also allows users to configure the gem on installation.  The call sets up the following flags for our user to configure:</p>

<ul>
<li><code>--with-stree-dir</code></li>
<li><code>--with-stree-include</code></li>
<li><code>--with-stree-lib</code></li>
</ul>

<h3>Finding headers and libraries</h3>

<p>Now that we've configured mkmf with where we can find libraries and headers, we need to search for required header files and libraries.  We'll do that with two functions: <code>find_header</code> and <code>find_library</code>.</p>

<p>We need to find the <code>stree/lst_string.h</code> header file, so we'll just supply that to the <code>find_header</code> method like so:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">unless</span> find_header(<span class="string"><span class="delimiter">'</span><span class="content">stree/lst_string.h</span><span class="delimiter">'</span></span>)
  abort <span class="string"><span class="delimiter">"</span><span class="content">libstree is missing.  please install libstree</span><span class="delimiter">"</span></span>
<span class="keyword">end</span>
</pre></div>
</div>
</div>

<p>This code will tell mkmf to find the header file we need.  If the header file can't be found, <code>find_header</code> will return false, and we can abort installation and provide some instructions.  If the <code>find_header</code> method is a success, the directory where the header file was found will be added to the <code>-I</code> flags that get passed to your compiler.</p>

<p>Next, we need to find the <code>libstree</code> dynamic library.  For this task, we'll use the <code>find_library</code> function call:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">unless</span> find_library(<span class="string"><span class="delimiter">'</span><span class="content">stree</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lst_stree_free</span><span class="delimiter">'</span></span>)
  abort <span class="string"><span class="delimiter">"</span><span class="content">libstree is missing.  please install libstree</span><span class="delimiter">"</span></span>
<span class="keyword">end</span>
</pre></div>
</div>
</div>

<p>The <code>find_library</code> function takes two arguments.  The first argument is the library that we need to link against.  This string will be passed to the <code>-l</code> flags.  The second argument is a symbol we need to find in the library.</p>

<p>In this code example, mkmf will create a test C program that tries to link against <code>stree</code> and find the function <code>lst_stree_free</code>.  If linking is successful, the path will be added to the <code>-L</code> flags provided to your compiler.  If it fails, we abort installation and provide an error message.</p>

<h3>Creating the Makefile</h3>

<p>Just like the last article we still need the call to <code>create_makefile</code> in our extconf.rb:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>create_makefile(<span class="string"><span class="delimiter">'</span><span class="content">stree/stree</span><span class="delimiter">'</span></span>)
</pre></div>
</div>
</div>

<p>You can find the complete extconf.rb <a href="https://github.com/tenderlove/stree/blob/part2/ext/stree/extconf.rb">here</a>.</p>

<h2>Wrapping <code>LST_String</code> from libstree</h2>

<p><code>libstree</code> defines a String type structure.  We're going to define a class in Ruby to wrap up this string type structure.  Eventually, we'll have some Ruby code that looks like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>string = <span class="constant">STree</span>::<span class="constant">String</span>.new <span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>
assert_equal <span class="integer">3</span>, string.length
</pre></div>
</div>
</div>

<p>In fact, since we're doing TDD let's start with a test for the length method.  We'll also add a test to ensure that objects other than String objects will raise a TypeError:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>require <span class="string"><span class="delimiter">'</span><span class="content">stree</span><span class="delimiter">'</span></span>
require <span class="string"><span class="delimiter">'</span><span class="content">test/unit</span><span class="delimiter">'</span></span>

<span class="keyword">module</span> <span class="class">STree</span>
  <span class="keyword">class</span> <span class="class">TestString</span> &lt; <span class="constant">Test</span>::<span class="constant">Unit</span>::<span class="constant">TestCase</span>
    <span class="keyword">def</span> <span class="function">test_length</span>
      string = <span class="constant">STree</span>::<span class="constant">String</span>.new <span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>
      assert_equal <span class="integer">3</span>, string.length
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">test_type_error</span>
      assert_raises(<span class="constant">TypeError</span>) <span class="keyword">do</span>
        <span class="constant">STree</span>::<span class="constant">String</span>.new <span class="constant">Object</span>.new
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></div>
</div>
</div>

<h3>File structure</h3>

<p>In my C projects, I like to make one C file per class.  We have to make an entry point though, so we'll keep <code>stree.h</code> and <code>stree.c</code> from our previous project.  Then we'll write <code>stree_string.h</code> and <code>stree_string.c</code> to keep our String class.</p>

<h3>Library entry point</h3>

<p>The entry point to our C code will be in <code>stree.c</code>.  The <code>stree.c</code> file will initialize the String class.  Here is the new <code>stree.h</code> file that includes libstree:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="preprocessor">#ifndef</span> RUBY_STREE
<span class="preprocessor">#define</span> RUBY_STREE

<span class="preprocessor">#include</span> <span class="include">&lt;ruby.h&gt;</span>;
<span class="preprocessor">#include</span> <span class="include">&lt;stree/lst_string.h&gt;</span>;

<span class="preprocessor">#include</span> <span class="include">&lt;stree_string.h&gt;</span>;

<span class="directive">extern</span> VALUE mSTree;

<span class="preprocessor">#endif</span>
</pre></div>
</div>
</div>

<p>We include header files from libstree, we include the header file for the string class, then we declare a global variable which will hold a reference to our Ruby "STree" module.</p>

<p>The new <code>stree.c</code> file looks like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="preprocessor">#include</span> <span class="include">&lt;stree.h&gt;</span>

VALUE mSTree;

<span class="directive">void</span> Init_stree()
{
  mSTree = rb_define_module(<span class="string"><span class="delimiter">"</span><span class="content">STree</span><span class="delimiter">"</span></span>);

  Init_stree_string();
}
</pre></div>
</div>
</div>

<p>When our library is required, <code>Init_stree</code> is called, then we'll define the STree module (assigning it to the global module variable) and initialize our String class.  Now we need to define <code>Init_stree_string</code> in <code>stree_string.h</code> and <code>stree_string.c</code>.</p>

<h3>Defining the String class</h3>

<p>First we'll create the header file for our string class.  We'll only have one public function called <code>Init_stree_string</code>, so our header file will look like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="preprocessor">#ifndef</span> RUBY_STREE_STRING
<span class="preprocessor">#define</span> RUBY_STREE_STRING

<span class="preprocessor">#include</span> <span class="include">&lt;stree.h&gt;</span>

<span class="directive">void</span> Init_stree_string();

<span class="preprocessor">#endif</span>
</pre></div>
</div>
</div>

<p>We include the main <code>stree.h</code> header file, then define our public initialize function.  Now we need to define the body of the <code>Init_stree_string</code> function in <code>stree_string.c</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="preprocessor">#include</span> <span class="include">&lt;stree_string.h&gt;</span>

<span class="directive">void</span> Init_stree_string()
{
  VALUE cSTreeString = rb_define_class_under(mSTree, <span class="string"><span class="delimiter">"</span><span class="content">String</span><span class="delimiter">"</span></span>, rb_cObject);
}
</pre></div>
</div>
</div>

<p>The <code>rb_define_class_under</code> function will define a class "String" in the module pointed to by <code>mSTree</code> with a parent class of <code>Object</code>.  This C code is equivalent to the following Ruby code:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="keyword">module</span> <span class="class">STree</span>
  <span class="keyword">class</span> <span class="class">String</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></div>
</div>
</div>

<p>At this point, you should be able to compile the project and run the tests.  We haven't defined any methods on the <code>STree::String</code> class in Ruby yet, but our project should compile, and the tests should execute.  If you're following along, you should see test output like this:</p>

<pre><code>  1) Error:
test_length(STree::TestString):
ArgumentError: wrong number of arguments (1 for 0)
    ./test/test_stree_string.rb:7:in `initialize'
    ./test/test_stree_string.rb:7:in `new'
    ./test/test_stree_string.rb:7:in `test_length'
</code></pre>

<h3>Allocating the String class</h3>

<p>The first thing we're going to do is teach Ruby how to allocate our String class.  Ruby gives us a hook when the <code>allocate</code> method is called where we can allocate internal structures (we're actually defining the <code>allocate</code> method on the STree::String class).</p>

<p>First, let's modify the init function to tell ruby about our allocate function:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="directive">void</span> Init_stree_string()
{
  VALUE cSTreeString = rb_define_class_under(mSTree, <span class="string"><span class="delimiter">"</span><span class="content">String</span><span class="delimiter">"</span></span>, rb_cObject);

  rb_define_alloc_func(cSTreeString, allocate);
}
</pre></div>
</div>
</div>

<p><code>rb_define_alloc_func</code> tells Ruby to call a function pointer <code>allocate</code> when this class gets allocated.  New we need to define our <code>allocate</code> function:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="directive">static</span> VALUE allocate(VALUE klass)
{
  LST_String * string = malloc(<span class="keyword">sizeof</span>(LST_String));

  <span class="keyword">return</span> Data_Wrap_Struct(klass, <span class="predefined-constant">NULL</span>, deallocate, string);
}
</pre></div>
</div>
</div>

<p>In our <code>allocate</code> function, we allocate enough memory to hold an <code>LST_String</code> struct.  Then we call <code>Data_Wrap_Struct</code> to return our actual Ruby object.  <code>Data_Wrap_Struct</code> takes four arguments:</p>

<ul>
<li>The Ruby class we're dealing with (in this case it's <code>cSTreeString</code></li>
<li>A function pointer that is called when the object is marked</li>
<li>A function pointer that is called with the object is freed</li>
<li>A void pointer of the data we want to wrap</li>
</ul>

<p>You'll notice we're referencing a function <code>deallocate</code> that isn't defined yet.  Let's define that function now:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="directive">static</span> <span class="directive">void</span> deallocate(<span class="directive">void</span> * string)
{
  lst_string_free((LST_String *)string);
}
</pre></div>
</div>
</div>

<p>The <code>deallocate</code> function is called with the pointer we passed to <code>Data_Wrap_Struct</code>, in this case an <code>LST_String</code> pointer.  We'll use the <code>lst_string_free</code> function from <code>libstree</code> to free our pointer.</p>

<h3>Defining STree::String#initialize</h3>

<p>Now we need to define the initialize method.  This method will take one argument (a string), and we'll populate the underlying <code>LST_String</code> struct with information from the Ruby string.</p>

<p>To define the initialize method, first we call <code>rb_define_method</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="directive">void</span> Init_stree_string()
{
  VALUE cSTreeString = rb_define_class_under(mSTree, <span class="string"><span class="delimiter">"</span><span class="content">String</span><span class="delimiter">"</span></span>, rb_cObject);

  rb_define_alloc_func(cSTreeString, allocate);
  rb_define_method(cSTreeString, <span class="string"><span class="delimiter">"</span><span class="content">initialize</span><span class="delimiter">"</span></span>, initialize, <span class="integer">1</span>);
}
</pre></div>
</div>
</div>

<p><code>rb_define_method</code> takes 4 arguments:</p>

<ul>
<li>The class on which we want to define a method</li>
<li>The name of the method we're defining</li>
<li>A function pointer that will be called when our method is called</li>
<li>The number of parameters passed to that function</li>
</ul>

<p>Next we need to define our <code>initialize</code> C function:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="directive">static</span> VALUE initialize(VALUE self, VALUE rb_string)
{
  LST_String * string;
  <span class="directive">void</span> * data;

  Check_Type(rb_string, T_STRING);

  Data_Get_Struct(self, LST_String, string);

  data = calloc(RSTRING_LEN(rb_string), <span class="keyword">sizeof</span>(<span class="predefined-type">char</span>));
  memcpy(data, StringValuePtr(rb_string), RSTRING_LEN(rb_string));

  lst_string_init(
      string,
      data,
      <span class="keyword">sizeof</span>(<span class="predefined-type">char</span>),
      RSTRING_LEN(rb_string));

  <span class="keyword">return</span> self;
}
</pre></div>
</div>
</div>

<p>The <code>initialize</code> function has two parameters, the first is the instance of our STree::String object, the second is the single parameter for our method.</p>

<p>After declaring our variables we check the type of the required argument.  <code>Check_Type</code> is a macro provided by Ruby to let us perform type checking on objects.  We use this macro to ensure that the user passed us a Ruby string.  If not, the <code>Check_Type</code> macro will automatically raise a type error.</p>

<p>Next we make a call to a macro provided by Ruby: <code>Data_Get_Struct</code>.  Our <code>LST_String</code> pointer is stored inside the Ruby VALUE object, and <code>Data_Get_Struct</code> will extract our pointer.  We give this macro the ruby object <code>self</code>, followed by the struct type we want to extract (<code>LST_String</code>), followed by the pointer where it will be assigned (<code>string</code>).</p>

<p>We need to copy the contents of the Ruby string to a buffer that our <code>LST_String</code> can keep.  To do that, we use:</p>

<ul>
<li><code>calloc</code> to allocate the memory</li>
<li><code>RSTRING_LEN</code> to get the number of bytes in our string</li>
<li><code>memcpy</code> to copy the memory contents</li>
<li><code>StringValuePtr</code> to get the underlying character pointer from Ruby</li>
</ul>

<p>We give the data to <code>libstree</code> by calling <code>lst_string_init</code>, then finally return <code>self</code>.</p>

<p>At this point, we should have one passing test and one failing test:</p>

<pre><code>  1) Error:
test_length(STree::TestString):
NoMethodError: undefined method `length' for #&lt;STree::String:0x101f0e6f8&gt;
    ./test/test_stree_string.rb:8:in `test_length'
</code></pre>

<p>Next we need to define the <code>length</code> method.</p>

<h3>Defining STree::String#length</h3>

<p>The hard part is over.  Defining the <code>length</code> method should be much easier than the <code>initialize</code> method.  Just like the initialize method, we need to call <code>rb_define_method</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="directive">void</span> Init_stree_string()
{
  VALUE cSTreeString = rb_define_class_under(mSTree, <span class="string"><span class="delimiter">"</span><span class="content">String</span><span class="delimiter">"</span></span>, rb_cObject);

  rb_define_alloc_func(cSTreeString, allocate);
  rb_define_method(cSTreeString, <span class="string"><span class="delimiter">"</span><span class="content">initialize</span><span class="delimiter">"</span></span>, initialize, <span class="integer">1</span>);
  rb_define_method(cSTreeString, <span class="string"><span class="delimiter">"</span><span class="content">length</span><span class="delimiter">"</span></span>, length, <span class="integer">0</span>);
}
</pre></div>
</div>
</div>

<p>This time, we're defining a function <code>length</code> that takes 0 arguments.  Now lets define the <code>length</code> C function:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="directive">static</span> VALUE length(VALUE self)
{
  LST_String * string;

  Data_Get_Struct(self, LST_String, string);

  <span class="keyword">return</span> INT2NUM(lst_string_get_length(string));
}
</pre></div>
</div>
</div>

<p>Just like the <code>initialize</code> function, we declare our variables, then unwrap our struct.  We use the <code>lst_string_get_length</code> function from <code>libstree</code> to get the string length as an integer.  Then we use a macro provided by Ruby, <code>INT2NUM</code>, that converts the integer to a Ruby Numeric object and return that object.</p>

<p>After we've defined this method, all of our tests should pass:</p>

<pre><code>Loaded suite -e
Started
..
Finished in 0.000873 seconds.

2 tests, 2 assertions, 0 failures, 0 errors
</code></pre>

<p>Yay!</p>

<h2>Conclusion</h2>

<p><em>OMG!  C CODE WRAPPED WITH RUBY!</em></p>

<p>We've scratched the surface for writing C extensions in Ruby.  In this part, we:</p>

<ul>
<li>taught our system how to find the library we want to use</li>
<li>(briefly) dealt with memory management of our objects</li>
<li>defined modules and classes</li>
<li>defined methods on our classes</li>
</ul>

<p>You can grab the code for <a href="https://github.com/tenderlove/stree/tree/part2">part 2 here</a>.</p>

<p>Happy holidays to EVERYONE!  I hope you liked Part 2 of Writing Ruby C Extensions!</p>

<p>&lt;3&lt;3&lt;3&lt;3&lt;3&lt;3&lt;3&lt;3 –tenderlove</p>

    </div>
    <p>
    <iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" class="twitter-follow-button twitter-follow-button-rendered" title="Twitter Follow Button" src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/follow_button.f7908d4abf5ce27173c69bdbb93aedb6.en.html" style="position: static; visibility: visible; width: 127px; height: 20px;" data-screen-name="tenderlove"></iframe>
    <script>
!function(d,s,id){
    var js, fjs = d.getElementsByTagName(s)[0], p=/^http:/.test(d.location)?'http':'https';
    if(!d.getElementById(id)){
      js=d.createElement(s);
      js.id=id;
      js.src=p+'://platform.twitter.com/widgets.js';
      fjs.parentNode.insertBefore(js,fjs);
    }
}(document, 'script', 'twitter-wjs');
    </script>
    </p>
    <a href="https://tenderlovemaking.com/">« go back</a>
  </div>
</article>
  </div><genius-back-page id="genius_back_page" style="visibility: hidden;"><iframe src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/back_page.html"></iframe></genius-back-page><genius-back-page-mobile-clickjacker></genius-back-page-mobile-clickjacker>
  <footer>
    <h2><a href="https://tenderlovemaking.com/archives.html">Archives</a></h2>
    <div class="copyright">           
      <p>Copyright © 2016 Tenderlovemaking.com All rights reserved.</p>
    </div><!--copyright-->  
  </footer>
  

<iframe id="rufous-sandbox" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: none;" title="Twitter analytics iframe" src="./Writing Ruby C Extensions_ Part 2 _ Tenderlovemaking_files/saved_resource.html"></iframe></body></html>